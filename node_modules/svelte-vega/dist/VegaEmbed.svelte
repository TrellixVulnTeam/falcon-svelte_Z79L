<script>var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
;
;
import { createEventDispatcher, onDestroy } from "svelte";
import vegaEmbed from "vega-embed";
import { WIDTH_HEIGHT } from "./constants";
import { addSignalListenersToView, updateMultipleDatasetsInView, combineSpecWithDimension, computeSpecChanges, removeSignalListenersFromView, shallowEqual, } from "./utils";
export let options;
export let spec;
export let view;
export let signalListeners = {};
export let data = {};
const dispatch = createEventDispatcher();
let result = undefined;
let prevOptions = {};
let prevSignalListeners = {};
let prevSpec = {};
let prevData = {};
let chartContainer;
$: {
    if (!shallowEqual(data, prevData)) {
        update();
    }
    prevData = data;
}
$: {
    if (chartContainer !== undefined) {
        // only create a new view if neccessary
        if (!shallowEqual(options, prevOptions, WIDTH_HEIGHT)) {
            createView();
        }
        else {
            const specChanges = computeSpecChanges(combineSpecWithDimension(spec, options), combineSpecWithDimension(prevSpec, prevOptions));
            const newSignalListeners = signalListeners;
            const oldSignalListeners = prevSignalListeners;
            if (specChanges) {
                if (specChanges.isExpensive) {
                    createView();
                }
                else if (result !== undefined) {
                    const areSignalListenersChanged = !shallowEqual(newSignalListeners, oldSignalListeners);
                    view = result.view;
                    if (specChanges.width !== false) {
                        view.width(specChanges.width);
                    }
                    if (specChanges.height !== false) {
                        view.height(specChanges.height);
                    }
                    if (areSignalListenersChanged) {
                        if (oldSignalListeners) {
                            removeSignalListenersFromView(view, oldSignalListeners);
                        }
                        if (newSignalListeners) {
                            addSignalListenersToView(view, newSignalListeners);
                        }
                    }
                    view.runAsync();
                }
            }
            else if (!shallowEqual(newSignalListeners, oldSignalListeners) &&
                result !== undefined) {
                view = result.view;
                if (oldSignalListeners) {
                    removeSignalListenersFromView(view, oldSignalListeners);
                }
                if (newSignalListeners) {
                    addSignalListenersToView(view, newSignalListeners);
                }
                view.runAsync();
            }
        }
        prevOptions = options;
        prevSignalListeners = signalListeners;
        prevSpec = spec;
    }
}
onDestroy(() => {
    clearView();
});
function createView() {
    return __awaiter(this, void 0, void 0, function* () {
        clearView();
        try {
            result = yield vegaEmbed(chartContainer, spec, options);
            view = result.view;
            if (addSignalListenersToView(view, signalListeners)) {
                view.runAsync();
            }
            onNewView(view);
        }
        catch (e) {
            handleError(e);
        }
    });
}
function clearView() {
    if (result) {
        result.finalize();
        result = undefined;
        view = undefined;
    }
}
function handleError(error) {
    dispatch("onError", {
        error: error,
    });
    console.warn(error);
    return undefined;
}
function onNewView(view) {
    update();
    dispatch("onNewView", {
        view: view,
    });
}
function update() {
    return __awaiter(this, void 0, void 0, function* () {
        if (data && Object.keys(data).length > 0 && result !== undefined) {
            view = result.view;
            updateMultipleDatasetsInView(view, data);
            yield view.resize().runAsync();
        }
    });
}
</script>

<div bind:this={chartContainer} />
